# 语法分析器

---



## 一、语法和语义

句子由词素（*token*）组成，而决定词素如何组合成句子的规则是语法（*syntax*）。

-   **语法 (Syntax)** 是语言的结构规则，它定义了词素（Token）如何按照特定的规则进行组合成合法的句子或表达式。语法分析的任务是检查代码结构是否正确，而不关心其具体含义。
-   **语义 (Semantic)** 是语言的含义层面，关注词素在上下文中的正确使用。语义分析检查语法正确的句子是否符合语言的逻辑和约定。

示例：

```cpp
int i;		float i;
i = 0;		i = 3.14;
i++;		i++;
```

-   语法上，`int i` 和 `float i` 都是合法的声明，因此这两条语句能够通过语法分析。
-   然而，从语义上看，`float i`; 语句会引发重复声明错误，而 `i = 3.14`; 第二个 `i++` 会因类型不匹配导致语义错误。

----



## 二、文法

**文法 (Grammar)** 是描述语言结构规则的工具，它通过一系列**产生式**（Production）规定了如何将词素组合成合法的句子。每条产生式描述了一个非终结符如何推导为终结符或其他非终结符。

假设我们有以下文法：
$$
S = aS\ |\ bS'\\
S' = a\ |\ \varepsilon
$$
这里，S 和 S' 是非终结符，a 和 b 是终结符，ε 表示空串。

在编程语言中，文法通常定义了程序中的各种语句、表达式和结构如何组合。例如：
$$
\rm{program \to var\_decl\ |\ function\_decl}\\
\rm{var\_decl \to struct\_decl\ |\ type\ id}\\
\rm{function\_decl \to type\quad id\quad (param)\quad \{\ statement\ \}}\\
\rm{param \to type\ id\ \cdots}\\
\rm{statement \to expression\_statement\ |\ return\_statement\ |\ etc.}\\
\rm{experssion \to id\ operator\ expression\ |\ id\ |\ \varepsilon\ |\ etc.}
$$
示例：

```cpp
struct student {
    size_t id;
    char name[30];
    int 
}

int add(int a, int b) {
	int sum;
	sum = a + b;
	return sum;
}

int main() {
	int tmp;
	tmp = add(3, 4);
	return 0;
}
```

这个文法以源代码为开始符，源代码可以是一个变量声明 (var_decl) 或一个函数声明 (function_decl), 而变量声明本身又由结构体声明(struct_decl) 或 数据类型 (type) 和 标识符 (id)组成, 函数声明本身又由类型、标识符、参数和函数体组成。以此类推。

---



## 三、递归下降 LL(1)

#### 1. 递归下降解析的基本概念

**递归下降解析** 是一种**自顶向下**的解析方法, 尤其适用于上下文无关文法。它通过一组递归函数来解析输入的词素序列 (Token流)。每个递归函数负责解析文法中的一个非终结符，并根据文法规则通过递归调用其它函数来解析产生式。

*虽然有更多高效的方法，但是我目前只对递归下降解析有一定理解，因此以此为例。*

#### 2. 递归下降解析的工作流程

假设我们有如下示例文法：
$$
S = aS\ |\ bS'\\
S' = a\ |\ \varepsilon
$$

规定大写字母为非终结符，小写字母为终结符，$\varepsilon $ 表示空串。

示例文法的递归下降解析伪代码：

```go
// 解析 S
parse_S (token) {
	if token == 'a' {
		parse_S(++token)	// 如果当前是'a', 继续解析 S
	} else if token == 'b' {
		parse_S'(++token)	// 如果当前是'b', 解析S'
	} else {
		panic(syntax_error)	// 如果没有匹配的产生式，抛出语法错误
	}
}

// 解析 S'
parse_S'(token) {
	if token == 'a' {
    	return success	// 如果当前是'a', 解析成功
    } else if token == '' {	// 空串匹配成功
        return success
    } else {
        panic(syntax_error)	// 如果没有匹配的产生式，抛出语法错误
    }
}
```

在这个解析过程中：

-   parse_S 函数尝试匹配 aS 或 bS’
-   如果匹配到 a，则递归调用 parse_S 来继续解析。
-   如果匹配到 b，则递归调用 parse_S' 来解析 S'。

递归下降解析方法能够有效处理大多数上下文无关文法。

然而，这种方法无法直接处理**左递归**的文法，因为左递归会导致解析过程进入无限递归。

#### 3. 什么是左递归

左递归指的是某个==非终结符在其产生式中递归地引用自身，并且递归发生在产生式的最左边==。通常，左递归的形式是：
$$
\rm{S \to Sa\ |\ b}
$$
其中，S 是非终结符，a 和 b 是终结符。左递归产生式的特点是**递归调用出现在产生式的最左边**。

#### 4. 为什么递归下降解析无法处理左递归

在递归下降解析中，`parse_S` 会尝试匹配 S 的产生式。如果当前符号是 S，递归调用会导致对 S 本身的再次解析，形成无限递归，无法停止。

因此，递归下降解析需要避免左递归文法，或通过重写文法转换为右递归。

#### 5.总结

-   递归下降解析是一种自顶向下的解析方法，基于递归调用来解析输入的符号流。
-   对于每个非终结符，都有一个对应的解析函数，负责处理文法中的产生式。
-   递归下降解析通过匹配输入符号流与文法规则进行递归调用，并通过消耗符号逐步解析，直到解析完成。
-   左递归会导致无限递归问题，需要通过改写文法来消除左递归，转换为右递归。
-   递归下降解析适用于许多常见文法，简单易用，但不适合处理左递归文法和某些复杂文法。

---



## 四、语法树

经过词法分析，源代码已经从字符序列转化为词素序列，语法分析将这些词素按照文法规则组合成合法的句子，并生成语法树（Parse Tree）或抽象语法树（AST）。

#### 1. 语法树概述

语法树是根据文法规则生成的树形结构，由终结符和非终结符组成。
**终结符通常是叶子节点，而父节点可以是终结符或非终结符**。

构建语法树的过程中，编译器可以发现语法错误。比如：

```cpp
var index int = 10;
```

编译器无法找到匹配的产生式，报告语法错误。

#### 2. 中序遍历语法树

语法树按照文法规则构建，每个父节点通常表示源代码中的结构（如表达式、语句、代码块等），而叶子节点表示具体的词素。中序遍历语法树的结果通常按照源代码的结构顺序输出，但中序遍历不仅仅从叶子节点开始，它需要通过父节点的引导来得到完整的语法结构。

总的来说，**中序遍历的过程通常会逐步生成源代码。**

简单的示例：

```cpp
// expression -> id operator expression | id | ø

sum = a + b
    
// syntax tree
    =
  /   \
sum   a + b
     /     \
    a       + b
           /   \
          +      b
```

可以看到，虽然叶子节点表示了源代码中的符号（如 a 和 b），但是父节点 “+” 是负责将它们结合起来的。因此，**只有通过父节点的结构，才能准确地还原源代码的逻辑**。

#### 3. 构建抽象语法树 (AST)

虽然语法树是非常详细的,它会包含所有的语法元素,包括无关的部分(如括号、分号等)。因此，在一些编译器中，语法树会被简化为**抽象语法树**。AST删除了许多与代码逻辑无关的细节，只保留了语法上必要的部分，使得进一步的处理更加高效。

#### 4. 总结

**构建语法树** 是编译器前端的重要步骤，由终结符和非终结符构成，可以通过中序遍历它还原源代码，在构建过程中发现语法错误，并为后续的语义分析作准备。

---



## 五、综述

**语法分析**是编译器前端的关键步骤之一，它负责检查源代码是否符合语言的语法规则。通过将源代码转化为语法树（或抽象语法树，AST），语法分析器帮助编译器理解代码的结构，为后续的语义分析、优化和代码作基础。

1.  语法分析的作用：
    -   解析源代码的结构，将源代码转化为一棵语法树。
    -   检查源代码是否符合预定义的文法规则，报告语法错误。
2.  语法树的作用：
    -   语法结构表示：通过语法树，编译器能够清晰地表示源代码的层次结构，直观地显示语言构造的关系。
    -   **错误检测**：语法树清晰地描述源代码的结构，还能在构建过程中发现语法错误。如果源代码不符合语言的文法，解析树会无法生成或在生成时出错，从而定位问题。
    -   后续编译阶段：语法树为语义分析、优化、中间代码生成等提供了基础支持。
3.  递归下降解析：
    递归下降解析是一种常用的语法分析方法，适用于**LL(1)** 文法。它通过递归的方式解析文法规则，将源代码逐步转化为语法树。递归下降解析具有简单、直观、易于实现的特点，但不能直接处理左递归文法，需通过转换为右递归文法来避免无限递归。
4.  左递归问题与解决：
    递归下降解析无法处理左递归文法，因为左递归会导致无限递归的问题。为了解决这一问题，编译器通常会将左递归文法转化为右递归文法，从而避免解析过程中的无限递归。

